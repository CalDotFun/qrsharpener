{"version":3,"sources":["QRSharpener.ts","index.ts"],"names":[],"mappings":"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","file":"qrsharpener.91fc5862.map","sourceRoot":"..","sourcesContent":["export interface RawImageData {\n    // series of rgba values\n    data: Uint8Array | Uint8ClampedArray;\n    width: number;\n    height: number;\n}\n\nexport class QRSharpener {\n\n    constructor(private readonly dimension: number, private readonly colorThreshold: number) {\n    }\n\n    public sharpen(imageData: RawImageData) {\n        const qrCodeBuffer = new Array<number>();\n        const annotatedImageBuffer = Array.from(imageData.data);\n\n        const blockSizeX = imageData.width / this.dimension;\n        const blockSizeY = imageData.height / this.dimension;\n\n        for (let y = 0; y < this.dimension; ++y) {\n            for (let x = 0; x < this.dimension; ++x) {\n\n                const px = x * Math.round(blockSizeX);\n                const py = y * Math.round(blockSizeY);\n\n                const nx = px + Math.round(blockSizeX / 2);\n                const ny = py + Math.round(blockSizeY / 2);\n\n                let pixelIndex = ((ny * imageData.width) + nx) * 4;\n                pixelIndex = QRSharpener.closestDividableBy(pixelIndex, 4);\n\n                const pixels = Array.from(imageData.data.slice(pixelIndex, pixelIndex + 4));\n\n                // choose whether a pixel is black or white\n                if (pixels[0] > this.colorThreshold || pixels[1] > this.colorThreshold || pixels[2] > this.colorThreshold)\n                    qrCodeBuffer.push(255, 255, 255, 255);\n                else\n                    qrCodeBuffer.push(0, 0, 0, 255);\n\n                // draw a red dot onto where we consumed the pixel from\n                annotatedImageBuffer[pixelIndex] = 255;\n                annotatedImageBuffer[pixelIndex + 1] = 0;\n                annotatedImageBuffer[pixelIndex + 2] = 0;\n                annotatedImageBuffer[pixelIndex + 3] = 255;\n            }\n        }\n\n        return {\n            qrCodeBuffer,\n            annotatedImageBuffer\n        }\n    }\n\n    // returns the number closest to n that is dividable by m\n    private static closestDividableBy(n: number, m: number) {\n        const quotient = n / m;\n        const number1 = m * quotient;\n        const number2 = (n * m) > 0 ? (m * (quotient + 1)) : (m * (quotient - 1));\n\n        if (Math.abs(n - number1) < Math.abs(n - number2))\n            return number1;\n        return number2;\n    }\n\n}","import { QRSharpener } from \"./QRSharpener\";\nimport { create } from \"domain\";\n\nconst annotatedImage = document.getElementById(\"annotatedImage\") as HTMLImageElement;\nconst resultImage = document.getElementById(\"resultImage\") as HTMLImageElement;\nconst uploader = document.getElementById(\"uploader\") as HTMLInputElement;\nconst statusDiv = document.getElementById(\"status\") as HTMLDivElement;\nconst dimensionsEdit = document.getElementById(\"dimensions\") as HTMLInputElement;\nconst canvas = document.createElement(\"canvas\");\nconst resultCanvas = document.createElement(\"canvas\");\n\nuploader.addEventListener(\"change\", fileUploaded, false);\n\nclass Spinner {\n    constructor(public readonly target: HTMLDivElement) {}\n    start() {\n        this.target.innerHTML = \"Computing...\";\n    }\n\n    stop() {\n        this.target.innerText = \"\";\n    }\n}\n\nfunction fileUploaded() {\n    const files = uploader.files;\n    if (files === null)\n        return;\n\n    const spinner = new Spinner(statusDiv);\n    spinner.start();\n    const file = files[0];\n    createImageBitmap(file).then(processFile).then(res => spinner.stop()).catch((err: any) => console.error(err));\n}\n\nfunction processFile(bitmap: ImageBitmap) {\n\n    canvas.width = bitmap.width;\n    canvas.height = bitmap.height;\n\n    const context = canvas.getContext(\"2d\");\n    if (context === null)\n        throw new Error(\"Cannot get 2d canvas context\");\n\n    const dimensions = parseInt(dimensionsEdit.value);\n\n    context.drawImage(bitmap, 0, 0);\n    const data = context.getImageData(0, 0, bitmap.width, bitmap.height);\n\n    const sharpener = new QRSharpener(dimensions, 50);\n    const result = sharpener.sharpen(data);\n\n    const resultImageData = new ImageData(Uint8ClampedArray.from(result.qrCodeBuffer), 29, 29);\n    const annotatedImageData = new ImageData(Uint8ClampedArray.from(result.annotatedImageBuffer), bitmap.width, bitmap.height);\n\n    renderResult(annotatedImageData, annotatedImage);\n    renderResult(resultImageData, resultImage);\n}\n\nfunction renderResult(imageData: ImageData, destination: HTMLImageElement) {\n    resultCanvas.width = imageData.width;\n    resultCanvas.height = imageData.height;\n\n    const context = resultCanvas.getContext('2d')!;\n    context.putImageData(imageData, 0, 0);\n    destination.src = resultCanvas.toDataURL();\n}"]}